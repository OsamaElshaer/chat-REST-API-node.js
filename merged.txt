const { httpServer } = require("./loaders/app");
const { port } = require("./config/env");
const { logger } = require("./utils/logger");
const { mongoConnect } = require("./loaders/database");
mongoConnect();
const server = httpServer.listen(port, async () => {
    logger.info("server on running", { port: port });
});
process.on("unhandledRejection", (err) => {
    logger.error("Unhandled Promise Rejection:", err.message);
    server.close((error) => {
        if (error) {
            logger.error(
                "Error occurred while closing the server:",
                error.message
            );
            process.exit(1);
        }
        logger.error("Server gracefully shut down");
        process.exit(1);
    });
});
process.on("uncaughtException", (err) => {
    logger.error("Uncaught Exception:");
    server.close(() => {
        logger.error("Server shut down due to uncaught exception", err.message);
        process.exit(1);
    });
});
const { userRouter } = require("./routes/auth.routes");
const { roomRouter } = require("./routes/room.routes");
const router = require("express").Router();

router.use("/users", userRouter);
router.use("/rooms", roomRouter);

module.exports.router = router;
const express = require("express");
const router = express.Router();
const { AuthService } = require("../../services/auth.service");
const { UserModel } = require("../../models/user.model");
const {
    validateSignup,
    validateLogin,
    valiadteforgetPassword,
    validateResetPassword,
} = require("../../utils/validations");

const userModel = new UserModel();
const userService = new AuthService(userModel);

const { signUp, login, forgetPassword, resetPassword } = userService;

router.post("/signup", validateSignup, signUp);
router.post("/login", validateLogin, login);
router.post("/forgetPassword", valiadteforgetPassword, forgetPassword);
router.post("/resetPassword/:resetToken", validateResetPassword, resetPassword);

module.exports.userRouter = router;
const express = require("express");
const { isAuth } = require("../../middlewares/isAuth");
const { RoomModel } = require("../../models/room.model");
const { RoomService } = require("../../services/room.service");
const router = express.Router();
const roomModel = new RoomModel();
const roomService = new RoomService(roomModel);
const {
    validateCreateRoom,
    validateRoomJoin,
} = require("../../utils/validations");

router.post("/create", isAuth, validateCreateRoom, roomService.create);
router.post("/join/:roomName", isAuth, validateRoomJoin, roomService.join);

exports.roomRouter = router;
const dotenv = require("dotenv");
dotenv.config();

const {
    PORT,
    WHITE_LIST,
    EMAIL,
    DB_HOST,
    NODEMAILER_USER,
    NODEMAILER_PASS,
    JWT_SECRET_KEY,
    SENDGRID_API_KEY,
    MAILTRAP_USER,
    MAILTRAP_PASS,
} = process.env;
module.exports = {
    port: PORT,
    whiteList: WHITE_LIST,
    email: EMAIL,
    dbHost: DB_HOST,
    nodemailerUser: NODEMAILER_USER,
    nodemailerPass: NODEMAILER_PASS,
    jwtSecretKey: JWT_SECRET_KEY,
    sendgridApiKey: SENDGRID_API_KEY,
    mailTrapUser: MAILTRAP_USER,
    mailTrapPass: MAILTRAP_PASS,
};
const swaggerUi = require("swagger-ui-express");
const YAML = require("yamljs");
const path = require("path");

const swaggerDocument = YAML.load(
    path.join(__dirname, "../config/swagger.yaml")
);

module.exports = (app) => {
    app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerDocument));
};
// express
const express = require("express");
const app = express();
const { createServer } = require("http");
const httpServer = createServer(app);
const { Server } = require("socket.io");

//npm packges
const cors = require("cors");
const helmet = require("helmet");
const hpp = require("hpp");
const rateLimit = require("express-rate-limit");
const morgan = require("morgan");

//require from modules
const { whiteList } = require("../config/env");
const { errorHandlerGlobal } = require("../middlewares/errorHandlerGlobal");
const { notFound404 } = require("../middlewares/notFound404");
const { logger } = require("../utils/logger");
const { router } = require("../api/index");
const swagger = require("../config/swagger");

// -----------------------------------------Middleware-----------------------------------------------------------

//parses the incoming JSON request body into a JavaScript object.
app.use(express.json());
// using the querystring library, which supports parsing simple form submissions. If you need to parse nested objects or arrays from the form data, you can set extended: true to use the qs library instead.
app.use(express.urlencoded({ extended: true }));

// handle socket connection

app.use((req, res, next) => {
    const io = new Server(httpServer, {
        cors: {
            origin: "*",
            methods: ["GET", "POST"],
            credentials: true,
        },
    });
    req.io = io;

    next();
});
// cors
const corsOptions = {
    origin: whiteList,
};
app.use(cors({ origin: "*" }));

//protect against HTTP Parameter Pollution attacks
app.use(hpp());

//Helmet helps secure Express apps by setting HTTP response headers.
app.use(helmet());

//limit requests rate
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per `window` (here, per 15 minutes)
    message: "Too many requests from this IP, please try again after an 15 min",
});
app.use(limiter);

//logging
let loggerStream = {
    write: (msg) => {
        return logger.info(msg);
    },
};
app.use(morgan("tiny", { stream: loggerStream }));

// -----------------------------------------Routes---------------------------------------------------------------
swagger(app);
app.use("/api", router);

// ---------------------------------------------------------------------------------------------------------------
//handling express errors
app.all("*", notFound404);

app.use(errorHandlerGlobal);

// ---------------------------------------------------------------------------------------------------------------

module.exports = { httpServer: httpServer };
const { MongoClient } = require("mongodb");
const { logger } = require("../utils/logger");
const { dbHost } = require("../config/env");

const url = dbHost;
let _db;

const mongoConnect = async () => {
    try {
        const client = await MongoClient.connect(url);
        if (process.env.NODE_ENV === "test") {
            _db = client.db("testChatty");
        } else {
            _db = client.db("chatty");
            logger.info("Connected to MongoDB successfully");
        }
    } catch (error) {
        logger.error("Failed to connect to the database:", error.message);
        throw new Error("Failed to connect to the database");
    }
};

const getDb =  () => {
    if (_db) {
        return _db;
    }
    throw new Error("No database connection");
};

module.exports = { mongoConnect, getDb };
exports.errorHandlerGlobal = (err, req, res, next) => {
    err.httpStatusCode = err.httpStatusCode || 500;
    let response = {
        name: err.name,
        message: err.message,
        httpStatusCode: err.httpStatusCode,
    };
    if (process.env.NODE_ENV === "development") {
        response.stack = err.stack;
    }
    return res.status(err.httpStatusCode).json(response);
};
const { validationResult } = require("express-validator");
const CustomError = require("../utils/customError");

exports.handleValidationErrors = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        const validationErrors = errors.array().map((error) => error.msg);
        throw new CustomError("Validation Error", 422, validationErrors);
    }
    next();
};
const jwt = require("jsonwebtoken");
const config = require("../config/env");
const CustomError = require("../utils/customError");
const isAuth = (req, res, next) => {
    try {
        const token = req.headers.authorization.split(" ")[1];
        const decoded = jwt.verify(token, config.jwtSecretKey);
        req.user = decoded;

        next();
    } catch (error) {
        throw new CustomError("Failed to get token", 401, error);
    }
};

module.exports.isAuth = isAuth;
const CustomError = require("../utils/customError");

exports.notFound404 = (req, res, next) => {
    next(
        new CustomError(
            "NotFound",
            404,
            `Can't find this route: ${req.originalUrl}`
        )
    );
};
const { getDb } = require("../loaders/database");

exports.Message = class Message {
    constructor(userName, roomName, message, time) {
        this.userName = userName;
        this.roomName = roomName;
        this.message = message;
        this.time = time;
    }
    save() {
        const db = getDb();
        db.collection("messages").insertOne(this);
    }
};
const { getDb } = require("../loaders/database");

class RoomModel {
    // Create a new room
    async create(name, createdBy) {
        const room = {
            name,
            createdBy,
            createdAt: new Date(),
            participants: [],
        };

        const result = await getDb().collection("rooms").insertOne(room);
        return result.insertedId;
    }

    // Get a room by its ID
    find = async (key, value) => {
        const query = { [key]: value }; // Dynamically use key parameter as the key name
        const room = await getDb().collection("rooms").findOne(query);
        return room;
    };

    addParticipants = async (roomId, userId) => {
        await getDb()
            .collection("rooms")
            .updateOne(
                { _id: roomId }, // Use the roomId to identify the room
                { $addToSet: { participants: userId } } // Add the userId to the participants array
            );
    };
}

module.exports.RoomModel = RoomModel;
const { getDb } = require("../loaders/database");

class UserModelAbstract {
    create(userName, email, password) {
        throw new Error("create method must be implemented in derived classes");
    }

    find(key, value) {
        throw new Error("find method must be implemented in derived classes");
    }

    update(userId, updatedUserData) {
        throw new Error("update method must be implemented in derived classes");
    }
}

class UserModel extends UserModelAbstract {
    create = async (userName, email, password) => {
        const user = {
            userName,
            email,
            password,
        };
        const db = await getDb();
        const result = await db.collection("users").insertOne(user);
        return result.insertedId;
    };

    find = async (key, value) => {
        const query = { [key]: value }; // Dynamically use key parameter as the key name
        const user = await getDb().collection("users").findOne(query);
        return user;
    };

    update = async (userId, updatedUserData) => {
        const db = await getDb();
        const result = await db
            .collection("users")
            .updateOne({ _id: userId }, { $set: updatedUserData });
        return result;
    };
}

exports.UserModel = UserModel;
const { sendMail } = require("../utils/sendMail");
const { validationResult } = require("express-validator");
const CustomError = require("../utils/customError");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const env = require("../config/env");
const { audit } = require("../utils/audit");
const crypto = require("crypto");
const {
    forgetPasswordTemplate,
    signUpTemplate,
} = require("../utils/mailMessages");

class AuthService {
    constructor(userModel) {
        this.userModel = userModel;
    }
    signUp = async (req, res, next) => {
        try {
            const { userName, email, password } = req.body;
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                throw new CustomError("signup", 422, errors.array()[0].msg);
            }
            const hashedPassword = await bcrypt.hash(password, 12);
            const userId = await this.userModel.create(
                userName,
                email,
                hashedPassword
            );
            //send mail
            const subject = "Welcome to Our Application!";
            const html = signUpTemplate(userName);

            sendMail(email, subject, html);

            audit(
                "User",
                "Signup",
                userName,

                req.method,
                res.statusCode
            );
            return res.status(201).json({
                msg: "User signed up successfully",
                data: { userId: userId, status: true },
            });
        } catch (error) {
            next(error);
        }
    };
    login = async (req, res, next) => {
        try {
            const user = req.user;
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                throw new CustomError("login", 422, errors.array()[0].msg);
            }
            const payload = { userId: user._id, userName: user.userName };

            const token = jwt.sign(payload, env.jwtSecretKey, {
                expiresIn: "24h",
            });
            audit("User", "Login", user.userName, req.method, res.statusCode);
            return res.status(201).json({
                msg: "user logged in ",
                data: { token: token, status: true },
            });
        } catch (error) {
            next(error);
        }
    };
    forgetPassword = async (req, res, next) => {
        try {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                throw new CustomError(
                    "forgetPassword",
                    422,
                    errors.array()[0].msg
                );
            }
            const buffer = await new Promise((resolve, reject) => {
                crypto.randomBytes(32, (err, buffer) => {
                    if (err) {
                        reject(
                            new CustomError(
                                "crypto randomToken",
                                422,
                                err.message
                            )
                        );
                    }
                    resolve(buffer);
                });
            });

            const resetToken = buffer.toString("hex");
            const resestTokenExpire = Date.now() + 600000;
            const passwordResetCount = 0;

            const user = req.user;
            user.token = { resetToken, resestTokenExpire, passwordResetCount };

            await this.userModel.update(user._id, user);

            const subject = "Forget Password";
            const html = forgetPasswordTemplate(resetToken);
            const sendMailRes = await sendMail(user.email, subject, html);

            audit(
                "User",
                "forget password",
                user.userName,
                req.method,
                res.statusCode
            );
            return res.status(201).json({
                msg: "Check your email to reset your password",
                data: {
                    sendMail: sendMailRes,
                    status: true,
                },
            });
        } catch (error) {
            next(error);
        }
    };

    resetPassword = async (req, res, next) => {
        try {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                throw new CustomError(
                    "resetPassword",
                    422,
                    errors.array()[0].msg
                );
            }
            const { password } = req.body;
            const user = req.user;
            const hashPassword = await bcrypt.hash(password, 12);
            user.password = hashPassword;
            user.token.passwordResetCount++;
            await this.userModel.update(user._id, user);
            audit(
                "User",
                "reset password",
                user.userName,
                req.method,
                res.statusCode
            );
            return res.status(201).json({
                msg: " user reset password successfully ",
                data: {
                    status: true,
                },
            });
        } catch (error) {
            next(error);
        }
    };
}

exports.AuthService = AuthService;
const { validationResult } = require("express-validator");
const { ObjectId } = require("mongodb");
const CustomError = require("../utils/customError");
const { messageFormat } = require("../utils/messageFormat");
const { handleSocketConnection } = require("../config/socketHandler");

class RoomService {
    constructor(roomModel) {
        this.roomModel = roomModel;
    }

    create = (req, res, next) => {
        try {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                throw new CustomError(
                    "create room",
                    422,
                    errors.array()[0].msg
                );
            }
            const { roomName } = req.body;
            const userId = new ObjectId(req.user["userId"]);
            this.roomModel.create(roomName, userId);
            return res.status(201).json({
                msg: `${roomName} has been created`,
                data: {
                    userId: userId,
                    roomName: roomName,
                },
            });
        } catch (error) {
            next(error);
        }
    };

    join = async (req, res, next) => {
        try {
            const roomName = req.params.roomName;
            const user = req.user;

            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                return next();
            }

            const io = req.io; // Get the io instance from the req.app object

            // Join the user to the specific room
            io.on("connection", async (socket) => {
                socket.join(roomName);

                // Send a welcome message to the user
                socket.emit(
                    "message",
                    messageFormat(
                        "BOT",
                        roomName,
                        `Welcome ${user.userName} to ${roomName} chat`
                    )
                );

                // Broadcast a message to all users in the room when a new user joins
                socket.broadcast
                    .to(roomName)
                    .emit(
                        "message",
                        messageFormat(
                            "BOT",
                            roomName,
                            `${user.userName} has joined the chat`
                        )
                    );

                // Chat message handling specific to this room
                socket.on("message", async (msg) => {
                    io.to(roomName).emit(
                        "message",
                        messageFormat(user.userName, roomName, msg)
                    );
                });

                // Handle user disconnection
                socket.on("disconnect", () => {
                    io.to(roomName).emit(
                        "message",
                        messageFormat(
                            "BOT",
                            roomName,
                            `${user.userName} has left the ${roomName} chat`
                        )
                    );
                });
            });

            res.status(200).json({
                msg: "bidirectional communication established",
            });
        } catch (error) {
            next(error);
        }
    };
}

exports.RoomService = RoomService;
const { EventEmitter } = require("events");
const { logger } = require("./logger");
const emitter = new EventEmitter();

emitter.on("audit", (e) => {
    logger.info(JSON.stringify(e));
});

exports.audit = (model, action, by, method, statusCode) => {
    const auditData = {
        model,
        action,
        by,
        date: new Date(),
        method,
        statusCode,
    };
    emitter.emit("audit", auditData);
};
class CustomError extends Error {
    constructor(name, httpStatusCode, message, status) {
        super(message);
        this.name = name;
        this.httpStatusCode = httpStatusCode;
        this.status = `${httpStatusCode}`.startsWith(4)
            ? "Server Error "
            : "Client Error";
    }
}

module.exports = CustomError;
const { createLogger, format, transports } = require("winston");
const { combine, timestamp, printf, colorize, metadata, errors, json } = format;

class Logger {
    constructor(name) {
        this.name = name;
        this.logger = createLogger({
            level: "info",
            defaultMeta: { service: this.name },
            transports: [
                process.env.NODE_ENV === "development"
                    ? new transports.Console({
                          format: combine(
                              timestamp(),
                              format.metadata({
                                  fillExcept: [
                                      "timestamp",
                                      "service",
                                      "level",
                                      "message",
                                  ],
                              }),
                              colorize(),
                              this.winstonConsoleFormat()
                          ),
                      })
                    : new transports.File({
                          filename: `./logs/${this.name}.log`,
                          format: combine(
                              timestamp(),
                              format.metadata({
                                  fillExcept: [
                                      "timestamp",
                                      "service",
                                      "level",
                                      "message",
                                  ],
                              }),
                              errors({ stack: true }),
                              json(),
                              this.winstonConsoleFormat()
                          ),
                      }),
            ],
        });
    }

    winstonConsoleFormat() {
        return printf(({ timestamp, level, message, metadata }) => {
            const metadataString = metadata ? JSON.stringify(metadata) : "";
            return `[${timestamp}][${level}] ${message} ${metadataString}`;
        });
    }

    debug(log, metadata) {
        this.logger.debug(log, metadata);
    }

    info(log, metadata) {
        this.logger.info(log, metadata);
    }

    warn(log, metadata) {
        this.logger.warn(log, metadata);
    }

    error(log, metadata) {
        this.logger.error(log, metadata);
    }

    // if want to make custom log level
    log(level, message, metadata) {
        this.logger.log(level, message, metadata);
    }
}

module.exports.logger = new Logger("Chatty");

const moment = require("moment");
const { Message } = require("../models/message.model");

exports.messageFormat = (userIdentity, roomId, text) => {
    const time = moment().format("h:mm a");
    const message = new Message(userIdentity, roomId, text, time);
    message.save();
    return {
        userIdentity,
        roomId,
        text,
        time: time,
    };
};
const nodemailer = require("nodemailer");
const sendgridTransport = require("nodemailer-sendgrid-transport");

const { logger } = require("./logger");
const env = require("../config/env");

exports.sendMail = async (emailTo, subject, html) => {
    try {
        let transporter;
        const mailOptions = {
            from: env.email,
            to: emailTo,
            subject: subject,
            html: html,
        };

        if (process.env.NODE_ENV === "test") {
            transporter = nodemailer.createTransport({
                host: "sandbox.smtp.mailtrap.io",
                port: 2525,
                auth: {
                    user: env.mailTrapUser,
                    pass: env.mailTrapPass,
                },
            });
        } else {
            transporter = nodemailer.createTransport(
                sendgridTransport({
                    auth: {
                        api_key: env.sendgridApiKey,
                    },
                })
            );
        }

        await transporter.sendMail(mailOptions);
        return true;
    } catch (error) {
        logger.warn("Error sending email:", { error: error.message });
        return false;
    }
};
const { body, param } = require("express-validator");
const bcrypt = require("bcrypt");
const { UserModel } = require("../models/user.model");
const { RoomModel } = require("../models/room.model");
const { AutoEncryptionLoggerLevel, ObjectId } = require("mongodb");
const userModel = new UserModel();
const roomModel = new RoomModel();

exports.validateSignup = [
    body("userName")
        .matches("^[0-9a-zA-Z ]+$", "i")
        .withMessage("Invalid username")
        .custom(async (value) => {
            const user = await userModel.find("userName", value);
            if (user) {
                throw new Error("User already exists");
            }
            return true;
        }),
    body("email", "Please enter a valid email address")
        .isEmail()
        .normalizeEmail(),

    body("password")
        .isLength({ min: 8 })
        .withMessage("Password must be at least 8 characters long")
        .matches(/[a-z]/)
        .withMessage("Password must contain at least one lowercase letter")
        .matches(/[A-Z]/)
        .withMessage("Password must contain at least one uppercase letter")
        .matches(/[0-9]/)
        .withMessage("Password must contain at least one digit")
        .matches(/[!@#$%^&*]/)
        .withMessage("Password must contain at least one special character")
        .custom((value, { req }) => {
            if (value !== req.body.passwordConfirmation) {
                throw new Error("Password confirmation is incorrect");
            }
            return true;
        }),
];
exports.validateLogin = [
    body("userName")
        .matches("^[0-9a-zA-Z ]+$", "i")
        .withMessage("Invalid username")
        .custom(async (value, { req }) => {
            const user = await userModel.find("userName", value);
            if (!user) {
                throw new Error("User does not exist");
            }
            req.user = user;
            return true;
        }),
    body("password")
        .isLength({ min: 8 })
        .withMessage("Invalid password")
        .custom(async (value, { req }) => {
            const user = req.user;
            const result = await bcrypt.compare(value, user.password);
            if (!result) {
                throw new Error("Incorrect password");
            }
            return true;
        }),
];
exports.valiadteforgetPassword = [
    body("email", "Please enter a valid email address")
        .isEmail()
        .normalizeEmail()
        .custom(async (value, { req }) => {
            const user = await userModel.find("email", value);
            if (!user) {
                throw new Error("There is no user with this email");
            }
            req.user = user;
            return true;
        }),
];

exports.validateResetPassword = [
    param("resetToken").custom(async (value, { req }) => {
        const user = await userModel.find({ "token.resetToken": value });
        if (
            !user ||
            Date.now() > user.token.resetTokenExpire ||
            user.token.passwordResetCount > 1
        ) {
            throw new Error("Token is not valid");
        }
        req.user = user;
    }),

    body("password")
        .isLength({ min: 8 })
        .withMessage("Password must be at least 8 characters long")
        .matches(/[a-z]/)
        .withMessage("Password must contain at least one lowercase letter")
        .matches(/[A-Z]/)
        .withMessage("Password must contain at least one uppercase letter")
        .matches(/[0-9]/)
        .withMessage("Password must contain at least one digit")
        .matches(/[!@#$%^&*]/)
        .withMessage("Password must contain at least one special character")
        .custom((value, { req }) => {
            if (value !== req.body.passwordConfirmation) {
                throw new Error("Password confirmation is incorrect");
            }
            return true;
        }),
];

exports.validateCreateRoom = [
    body("roomName")
        .notEmpty()
        .withMessage("Room name is required")
        .isLength({ min: 3, max: 25 })
        .withMessage("Room name must be between 3 and 50 characters")
        .trim()
        .custom(async (value) => {
            const room = await roomModel.find("name", value);
            if (room) {
                throw new Error("room name is already exist");
            }
        }),
];

exports.validateRoomJoin = [
    param("roomName").custom(async (value, { req }) => {
        const room = await roomModel.find("name", value);
        if (!room) {
            throw new Error("there is no room with this name");
        }
        req.room = room;
        return true;
    }),
];
